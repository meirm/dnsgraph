#!/usr/bin/perl -w
# dnsgraph -- a bind statistics rrdtool frontend
#
# based on mailgraph by David Schweikert <dws@ee.ethz.ch>
# modified by Jicheng Qu
# modified by Przemyslaw Sztoch <navy@navy.wox.org>
#
# copyright (c) 2003
# released under the GNU General Public License
##################################################
# The BIND DNS stats are generated by 'rndc stats'
# We need a cron job to generate stats every minute
# install perl-File-Tail
################################################## 

use RRDs;
use Time::Local;

use strict;
use File::Tail;
use Getopt::Long;

my $VERSION = 0.9;

# config
my $rrdstep = 60;
my $xpoints = 600;
my $points_per_sample = 3;

# global variables
my $logfile = '/var/lib/named/named-stats.log';
my $rrd = '/var/lib/named/named-stats.rrd';
my $year;
my $this_minute;
my $time;
my $rrd_inited=0;
my $success=0;
my $failure=0;
my $recursion=0;
my $referral=0;
my $nxrrset=0;
my $nxdomain=0;
my $interested=0;

# Since the output of rndc is the sum of the statistics
# We need to know every minute statistics
#
my $p_time = -1;
my $p_success = -1;
my $p_failure = -1;
my $p_recursion = -1;
my $p_referral = -1;
my $p_nxrrset = -1;
my $p_nxdomain = -1;


# prototypes
sub first_rec();
sub reset_rec();
sub process_line($);
sub init_rrd($);
sub round_rec($$$);
sub update();

sub first_rec()
{
    return 1 if($p_time == -1);
    return 1 if($p_success == -1);
    return 1 if($p_failure == -1); 
    return 1 if($p_recursion == -1);
    return 1 if($p_referral == -1); 
    return 1 if($p_nxrrset == -1);
    return 1 if($p_nxdomain == -1);
    return 0; 
}

sub reset_rec()
{
    $p_time = $time;
    $p_success = $success;
    $p_failure = $failure;
    $p_recursion = $recursion;
    $p_referral = $referral;
    $p_nxrrset = $nxrrset;
    $p_nxdomain = $nxdomain;
}

sub usage
{
	print "usage: dnsanalise [*options*]\n\n";
	print "  -c, --cat          causes the logfile to be only read and not monitored\n";
	print "  -r, --rrdfile f    monitor logfile f instead of $rrd\n";
	print "  -l, --logfile f    monitor logfile f instead of $logfile\n";
	print "  -h, --help         display this help and exit\n";
	print "  -v, --version      output version information and exit\n";

	exit;
}

sub main
{
	my %opt = ();
	GetOptions(\%opt, 'help|h', 'cat|c','rrdfile|r=s', 'logfile|l=s', 'version|v') or usage;
	usage if $opt{help};

	if($opt{version}) {
		print "dnsgraph $VERSION\n";
		exit;
	}

	if(defined $opt{rrdfile}) {
	    $rrd = $opt{rrdfile};
	}

	if(defined $opt{logfile}) {
	    $logfile = $opt{logfile};
	}

	if($opt{cat}) {
		open(FILE, "<$logfile") or die "can't open $logfile\n";
		while(<FILE>) {
			process_line($_);
		}
	}
	else {
		my $file = File::Tail->new(name=>$logfile, tail=>-1);
		my $line;
		while (defined($line=$file->read)) {
			process_line($line);
		}
	}
}

sub init_rrd($)
{
	my $m = shift;
	if(not -f $rrd) {
		my $rows = $xpoints/$points_per_sample;
		my $realrows = int($rows*1.1); # ensure that the full range is covered
		my $day_steps = int(3600*24 / ($rrdstep*$rows));
		# use multiples, otherwise rrdtool could choose the wrong RRA
		my $week_steps = $day_steps*7;
		my $month_steps = $week_steps*5;
		my $year_steps = $month_steps*12;
		RRDs::create($rrd, '--start', $m, '--step', $rrdstep,
				'DS:success:ABSOLUTE:'.($rrdstep*2).':0:U',
				'DS:failure:ABSOLUTE:'.($rrdstep*2).':0:U',
				'DS:recursion:ABSOLUTE:'.($rrdstep*2).':0:U',
				'DS:referral:ABSOLUTE:'.($rrdstep*2).':0:U',
                                'DS:nxrrset:ABSOLUTE:'.($rrdstep*2).':0:U',
                                'DS:nxdomain:ABSOLUTE:'.($rrdstep*2).':0:U',
				"RRA:AVERAGE:0.5:$day_steps:$realrows",   # day
				"RRA:AVERAGE:0.5:$week_steps:$realrows",  # week
				"RRA:AVERAGE:0.5:$month_steps:$realrows", # month
				"RRA:AVERAGE:0.5:$year_steps:$realrows",  # year
				"RRA:MAX:0.5:$day_steps:$realrows",   # day
				"RRA:MAX:0.5:$week_steps:$realrows",  # week
				"RRA:MAX:0.5:$month_steps:$realrows", # month
				"RRA:MAX:0.5:$year_steps:$realrows",  # year
				);
		$this_minute = $m;
	}
	else {
		$this_minute = RRDs::last($rrd) + $rrdstep;
	}
	$rrd_inited=1;
}

sub process_line($) {
    my $line = shift;
    chomp $line;
    my $L_number = 0;
    my $L_zone;
    $line =~ /^\s*(\d+)/ and $L_number = $1;
    if ( $line =~ /^\+\+\s/ ) {
        if ( $line =~ /Name Server Statistics/ ) {
            $interested = 1;
        }
        else {
            $interested = 0;
        }
    }
    $interested = 0 if $line =~ /^\[/;

    if ( $line =~ /^\+\+\+/ ) {
        $line =~ /\((\d+)\)/
          ; # Select time stamp from first line of dump (\d+) = one or more digit characters
        $time      = $1;    # $1 is what the pattern between the brackets found
        $success   = 0;
        $failure   = 0;
        $recursion = 0;
        $referral  = 0;
        $nxrrset   = 0;
        $nxdomain  = 0;
    }
    elsif ( $line =~ /^---/ ) {
        update();
        $interested = 0;
    }
    elsif ( $L_number && $interested ) {
        if    ( $line =~ /successful/ )   { $success   = $L_number; }
        elsif ( $line =~ /failure/ )   { $failure   = $L_number; }
        elsif ( $line =~ /SERVFAIL/ )  { $failure   = $L_number; }
        elsif ( $line =~ /recursion/ ) { $recursion = $L_number; }
        elsif ( $line =~ /referral/ )  { $referral  = $L_number; }
        elsif ( $line =~ /nxrrset/ )   { $nxrrset   = $L_number; }
        elsif ( $line =~ /NXDOMAIN/ )  { $nxdomain  = $L_number; }
    }
}

sub round_rec($$$)
{
    my $first = shift;
    my $second = shift;
    my $loop = shift;
    my $result = int 100*($first-$second)/$loop;
    return $result/100;
}

# returns 1 if $sum should be updated
sub update()
{
        if(first_rec() == 1)
        {
             reset_rec();
             return 0;
        }
        my $t = $time;
        my $m = $t - $t%$rrdstep;
        init_rrd($m) unless $rrd_inited;
        return 1 if $m == $this_minute;
        return 0 if $m < $this_minute;

        my $loop =  ($time - $p_time)/$rrdstep;
        if ($loop < 0) { reset_rec(); return 0;  }
        my $c_success = round_rec($success, $p_success, $loop);
        if ($c_success < 0) { reset_rec(); return 0;  }
        my $c_failure = round_rec($failure, $p_failure, $loop);
        if ($c_failure < 0) { reset_rec(); return 0;  }
        my $c_recursion = round_rec($recursion, $p_recursion, $loop);
        if ($c_recursion < 0) { reset_rec(); return 0;  }
        my $c_referral = round_rec($referral, $p_referral, $loop);
        if ($c_referral < 0) { reset_rec(); return 0;  }
        my $c_nxrrset = round_rec($nxrrset, $p_nxrrset, $loop);
        if ($c_nxrrset < 0) { reset_rec(); return 0;  }
        my $c_nxdomain = round_rec($nxdomain, $p_nxdomain, $loop);
        if ($c_nxdomain < 0) { reset_rec(); return 0;  }
	if($m >= $this_minute+$rrdstep) {
	    for(my $sm=$this_minute+$rrdstep;$sm<$m+10;$sm+=$rrdstep) {
    		print "update $sm:$c_success:$c_failure:$c_recursion:$c_referral:$c_nxrrset:$c_nxdomain\n";
		RRDs::update $rrd, "$sm:$c_success:$c_failure:$c_recursion:$c_referral:$c_nxrrset:$c_nxdomain";
	    }
	}
	$this_minute = $m;
        reset_rec();
	return 1;
}

main;
